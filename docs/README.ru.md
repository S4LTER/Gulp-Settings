# Документация

## Содержание

- [Документация](#документация)

  - [Содержание](#содержание)
  - [Быстрый старт](#быстрый-старт)
  - [Разработка](#разработка)
  - [Сборка проекта](#сборка-проекта)
  - [Деплой на GitHub Pages](#деплой-на-github-pages)
  - [Структура проекта](#структура)
  - <details>
      <summary><b>Общее</b></summary>

    - [CSS](#css)
    - [HTML](#html)
      - [Страницы](#страницы)
    - [JavaScript](#javascript)
    - [Локальные шрифты](#шрифты)
    - [SVG-спрайты](#svg-спрайты)
    - [Данные](#данные)
    - [Библиотеки](#библиотеки)
    </details>

  - <details>
      <summary><b>Рекомендации к использованию</b></summary>

    - [Хранилище текстовых данных](#текстовое-хранилище-данных-импровизированная-база-данных)
    - [Компонентный подход](#компонентный-подход)
      - [Структура компонентов](#структура-компонентов)
    - [Активный класс для ссылки на текущую страницу](#активный-класс-для-ссылки-на-текущую-страницу)

    </details>

  - [CLI](#cli)
  - [Линтинг кода](#линтинг-кода)
    - [Проверка кода на ошибки](#простая-проверка-кода)
    - [Автоматическое исправление ошибок](#автоматическое-исправление)
  - [Генератор компонентов](#генератор-компонентов)
  - [Лицензия](#лицензия)

## Быстрый старт

Убедитесь, что у вас установлен [Node.js](https://nodejs.org/en/).

1. Установите [Yarn](https://yarnpkg.com/) глобально:

```console
$ npm i -g yarn
```

2. Установите [Gulp](https://gulpjs.com/) и [bem-tools](https://en.bem.info/) глобально:

```console
$ yarn add --global gulp bem-tools-core bem-tools-create
```

3. Клонируйте сборку:

```console
$ git clone https://github.com/joseffie/gulp-joseffie-settings.git my-project
```

4. Перейдите к клонированной сборке и установите необходимые зависимости:

```console
$ yarn
```

5. После установки зависимостей вы можете запустить сервер для разработки:

```console
$ yarn run dev
```

## Разработка

1. Запустите `yarn run dev`, чтобы увидеть ваше приложение на `http://localhost:9050/`.

> **ПРИМЕЧАНИЕ:** С целью обеспечить обеспечить быстрый старт разработки, SVG спрайты автоматически <ins>НЕ</ins> компилируются. Если ваш проект содержит SVG, вы должны скомпилировать SVG иконки самостоятельно перед стартом разработки:

```console
$ yarn run build:sprites   # конвертирует SVG иконки в SVG спрайт
```

> Вам не нужно это делать, если вы запускаете `yarn run build` или `yarn run deploy`.

## Сборка проекта

1. Запустите `yarn run build`, чтобы собрать ваш проект в режиме продакшн. Этот режим автоматически соберёт SVG спрайты, конвертирует локальные шрифты, создав SCSS файл с объявлениями `@font-face`, оптимизирует изображения, минифицирует файлы.

## Деплой на GitHub Pages

1. Запустите `git init`, чтобы инициализировать Git.
2. Запушьте ваш проект в репозиторий.
3. Запустите `yarn run deploy`. Эта команда соберёт ваш проект в режиме продакшн и запушит содержимое папки `dist` в ветку `gh-pages` вашего GitHub-репозитория.
4. Вы можете перейти к своему проекту на GitHub Pages по адресу `username.github.io/repository-name`.

## Структура

```
gulp-joseffie-settings/              # Корень проекта
├── dist                             # Скомпилированные файлы
├── docs                             # Документация
├── gulp                             # Gulp-таски и конфиг
├── src
|   ├── base
|   |   ├── data                     # Папка с data.json
|   |   ├── scripts
|   |   |   ├── helpers              # Различные JS-хелперы
|   |   |   ├── index.js             # Главный JS-файл
|   |   ├── pug                      # Pug-шаблоны
|   |   ├── styles
|   |   |   ├── core
|   |   |   |   ├── mixins           # Системные миксины проекта
|   |   |   |   ├── typography       # Стили типографии
|   |   |   |   ├── variables        # Системные переменные проекта
|   |   |   ├── _common.scss         # Общие стили
|   |   |   ├── _variables.scss      # Переменные проекта
|   |   |   ├── main.scss            # Основной файл стилей
|   |   |   ├── reset.scss           # Файл обнуления стилей
|   ├── components                   # Папка с компонентами
|   ├── fonts                        # Локальные шрифты
|   ├── img
|   ├── views                        # Pug-страницы
|   ├── svgico
|   |   ├── mono                     # Одноцветные SVG иконки
|   |   ├── multi                    # Многоцветные SVG иконки
|   ├── vendor                       # Файлы библиотек
└── templates                        # шаблоны для bem-create
└── .archive                         # Папка с архивом проекта
```

## Общее

### CSS

- [Sass (SCSS syntax)](https://sass-lang.com/) - популярный, функциональный CSS-препроцессор. Возможно писать на обоих синтаксисах (Sass и SCSS) в проекте одновременно.
- [PostCSS](https://postcss.org/)
  - [Autoprefixer](https://github.com/postcss/autoprefixer) - добавляет вендорные префиксы там, где это нужно, руководствуясь [Can I Use](https://caniuse.com/).
  - [CSSNANO](https://cssnano.co/) - набор PostCSS плагинов, который оптимизирует ваш CSS-код.
  - [postcss-preset-env](https://github.com/csstools/postcss-plugins/tree/main/plugin-packs/postcss-preset-env) - плагин, который конвертирует современный CSS-код в код, понятный браузерам.
  - [css-mqpacker](https://github.com/hail2u/node-css-mqpacker) - плагин, который объединяет несколько одинаковых медиа-запросов в один.
  - [postcss-flexbugs-fixes](https://github.com/luisrudge/postcss-flexbugs-fixes) - плагин, который фиксит баги в Flex-разметке
- [Stylelint.](https://stylelint.io/)
  - [Stylelint-order](https://github.com/hudochenkov/stylelint-order) - помогает держать правила и свойства в определённом порядке.

### HTML

- [Pug (он же Jade)](https://pugjs.org/api/getting-started.html) - удобный и функциональный шаблонизатор.
- [PostHTML](https://github.com/posthtml/posthtml) - инструмент для преобразования HTML/XML кода с помощью JS-плагинов.

#### Страницы

Папка `src/views` содержит файлы страниц. Каждая из страниц должна наследовать шаблон `src/base/pug/default.pug`.

Переменные блока `pageConfig` могут быть использованы, чтобы манипулировать контентом страниц. Синтаксис:

```pug
//- Это предпочительно объявлять в начале файла страницы
block pageConfig
  -
    title = '<title-name>'
    pageUrl = '<url>'
    bodyClass = ['<body-class-1>', '<body-class-2>', 'body-class-...']
```

- Переменная `title` определяет название страницы.
- Используя переменную `pageUrl`, вы можете выдать ссылке на текущую страницу, находящейся в главном меню (в хедере), активный класс ([подробнее](#активный-класс-для-ссылки-на-текущую-страницу)).
- С помощью объекта `bodyClass` вы можете добавить какие-то классы тегу `body`.

### JavaScript

- Инструменты:
  - [Node.js](https://nodejs.org/en/) - среда выполнения JavaScript.
  - [Webpack 5](https://webpack.js.org/) - сборщик модулей.
  - [Babel](https://babeljs.io/) - JavaScript-транспилер.
  - [Yarn](https://yarnpkg.com/) - менеджер пакетов.

### Шрифты

Размещайте локальные шрифты в папке `src/fonts`. Вы можете использовать `otf`, `ttf`, `woff`, `woff2` форматы.

> Очень важно, чтобы название шрифта имело формат "Имя-Начертание", например "Roboto-Regular" или "IbarraRealNova-MediumItalic". Иначе Gulp-таск не сможет определить font-weight и font-style шрифта, либо сделает это некорректно. Из-за чего в `_fonts.scss` попадут некорректные значения в `@font-face`.

Чтобы скомпилировать локальные шрифты и создать файл стилей шрифтов, запустите `yarn run build:fonts`. После использования данной команды, в папке `src/base/styles` появится файл `_fonts.scss`, который содержит объявления `@font-face` для шрифтов.

Чтобы использовать локальные шрифты в стилях, не забудьте раскомментировать эту строку в файле `src/base/styles/reset.scss`:

```scss
// @import '_fonts';
```

### SVG-спрайты

Чтобы конвертировать SVG-иконки в SVG-спрайт, вам нужно совершить несколько простых действий:

1. В зависимости от количества цветов в ваших SVG, поместите иконки в соответствующие папки: если иконка имеет только один цвет, поместите её в `src/svgico/mono`, иначе - в `src/svgico/multi`. Такое разделение на цвета нужно, чтобы каждый из типов иконок (одноцветный/многоцветный) был оптимизирован по мере своей надобности. К примеру, у одноцветных иконок будет убрана заливка, благодаря чему цвет иконки будет легко менять с помощью CSS, иначе этому препятствует `Shadow DOM`.
2. Запустите `yarn run build:sprites`.
3. В нужном вам Pug-компоненте импортируйте миксин для вставки иконок: `include ../icon/icon.pug`.
4. Используйте `+icon(name='название-иконки', type='тип-иконки'). Пара примеров:

```pug
+icon(name='logo' type='multi')
+icon(name='apple' type='mono')
```

### Данные

Все текстовые данные содержатся в `src/base/data/data.json`.

### Библиотеки

Устанавливайте файлы библиотек в папку `src/vendor`.

SCSS-файлы библиотек импортируйте в `src/vendor/_vendor.scss`.

JS-файлы библиотек импортируйте в `src/vendor/vendor.js`. Если вы что-то импортировали в этот файл, не забудьте сделать несколько действий, чтобы всё сработало:

1. В `webpack.config.babel.js` раскомментируйте строку, содержащую свойство `vendor` в объекте `entry`:

```js
const webpackConfig = {
  entry: {
    index: './index.js',
    // vendor: '../../vendor/vendor.js', # раскомментируйте эту строку
  },
};
```

2. В файле страницы, в которую вы хотите добавить скрипт библиотеки, например `index.pug`, вставьте:

```pug
block append scripts
  scripts(src='scripts/vendor.js')
```

Если вы хотите, чтобы скрипт был включён во все страницы вашего проекта, вы можете добавить данный скрипт сразу в шаблон `src/base/pug/default.pug`, в блок `scripts`:

```pug
block scripts
  script(src='scripts/index.js')
  script(src='scripts/vendor.js') //- добавьте это в блок
```

## Рекомендации к использованию

### Текстовое хранилище данных (импровизированная база данных)

Чтобы не захламлять код Pug-файлов текстовыми данными, лучше перенести все тексты в отдельные файлы. Под текстом имеется в виду, к примеру, параграфы статьи или какие-то списки, или те же пункты меню в хедере, в футере, в сайдбаре и т.д. Всё это приводит к удобочитаемости кода, а исправлять ошибки будет проще, когда всё в одном месте.

Вы можете хранить все тексты в файле `data.json` (`src/base/data/data.json`). HTML-разметка допустима, но в Pug нужно интерполировать значение с помощью оператора `!=`, чтобы символы HTML-разметки были экранированы. Например, `p!= variable`.

Файл `data.json` уже включён во все Pug-файлы по умолчанию и парсится с помощью gulp-таска.

Если вы хотите использовать это, вы должны создать массив объектов и заполнить его текстовой информацией. Давайте взглянем на пример создания простого списка, используя `data.json`.

Сначала нужно ввести текст элементов списка в `data.json`:

```json
{
  "paradigms": [
    { "title": "Abstraction" },
    { "title": "Encapsulation" },
    { "title": "Polymorphism" }
  ]
}
```

Затем мы можем перебрать данный массив в Pug с помощью встроенного цикла `each in`:

```pug
h3.list-label Paradigms of OOP:
ul.list
  each item in paradigms
    li.list-item!= item.title
```

Конечным результатом этого кода будет такая HTML-разметка:

```html
<h3 class="list-label">Paradigms of OOP:</h3>
<ul class="list">
  <li class="list-item">Abstraction</li>
  <li class="list-item">Encapsulation</li>
  <li class="list-item">Polymorphism</li>
</ul>
```

### Компонентный подход

Для переиспользования и лёгкой расширяемости вёрстки, вам следует разделять код на компоненты. Все компоненты находятся в папке `src/components`.

Pug-файлы компонентов следует оформлять в виду миксинов, это позволяет легко изменять контент компонента, если вы хотите использовать его в нескольких местах, без создания похожего компонента или изменения старого.

Вы можете вставить Pug-файлы компонентов в файлы страниц или в другие компоненты. Импортируйте SCSS-файлы компонентов в `src/components/components.scss`. JS-файлы компонентов импортируйте в `src/components/components.js`.

Чтобы узнать, как проще создавать компоненты, см. [Генератор компонентов](#генератор-компонентов).

#### Структура компонентов

```
src
├── components                    # Папка компонентов
|   ├── component-name            # Папка компонента
|   |   ├── component-name.pug    # Pug-файл компонента
|   |   ├── component-name.scss   # SCSS-файл компонента
|   |   ├── component-name.js     # JS-файл компонента
|   ├── components.scss           # Импорты SCSS-файлов компонентов
|   ├── components.js             # Импорты JS-файлов компонентов
```

### Активный класс для ссылки на текущую страницу

Если вам нужно выделить ссылку на страницу, на которой сейчас находится пользователь, тогда в файле соответствующей страницы вы должны определить `block pageConfig` и в переменной `pageUrl` этого блока указать `url` нужной вам ссылки, объявленный в `src/base/data/data.json` в `mainNavData`.

```pug
block pageConfig
  - pageUrl = 'index.html'; //- одинаковые значения
```

```jsonc
{
  "mainNavData": [
    {
      "title": "Home",
      "url": "index.html" // одинаковые значения
    },
    {
      "title": "About us",
      "url": "about.html"
    }
  ]
}
```

В миксине `main-nav.pug`, когда перебирается массив `mainNavData`, некоторые условия использованы для того, чтобы возвращать определённые классы текущей ссылке, среди которых условие, которое выдаёт активный класс (`main-nav__item_active`), если `pageUrl` и `url` текущей ссылки равны.

```pug
each item in mainNavData
  - var itemClasses = ['main-nav__item'];

  if (item.url === pageUrl)
    - itemClasses.push('main-nav__item_active');

  li(class=itemClasses)
```

Результатом будет такая HTML-разметка:

```html
<nav class="main-nav">
  <ul class="main-nav__list">
    <li class="main-nav__item main-nav__item_active">
      <a href="index.html">Home</a>
    </li>
    <li class="main-nav__item"><a href="about.html">About us</a></li>
  </ul>
</nav>
```

## CLI

|    Команда    |                                                         Описание                                                         |
| :-----------: | :----------------------------------------------------------------------------------------------------------------------: |
|      dev      |                                           запускает сборку в режиме разработки                                           |
|     build     | оптимизирует исходные файлы, компилирует файлы препроцессоров в файлы, понимаемые браузером, и отправляет в папку `dist` |
|      zip      |                                     оптимизирует исходные файлы и архивирует проект                                      |
|   build:pug   |                                     оптимизирует файлы страниц и отправляет в `dist`                                     |
| build:styles  |                                     оптимизирует файлы стилей и отправляет в `dist`                                      |
| build:scripts |                                       оптимизирует JS файлы и отправляет в `dist`                                        |
| build:images  |                                      оптимизирует изображения и отправляет в `dist`                                      |
|  build:fonts  |     конвертирует локальные шрифты в форматы woff/woff2, автоматически создаёт SCSS файл с объявлениями `@font-face`      |
| build:sprites |                                           конвертирует SVG иконки в SVG спрайт                                           |
|    deploy     |                         запускает `build`, затем пушит сборку на GitHub Pages (ветка `gh-pages`)                         |
|    publish    |                                   пушит сборку на GitHub Pages, но без запуска `build`                                   |
|   lint:pug    |                                               проверяет Pug код на ошибки                                                |
|  lint:styles  |            проверяет SCSS код на ошибки. Если указать флаг `--fix`, то ошибки будут автоматически исправлены             |
| lint:scripts  |             проверяет JS код на ошибки. Если указать флаг `--fix`, то ошибки будут автоматически исправлены              |

### Линтинг кода

_Заставляет вас следовать жесткому кодгайду, что обеспечивает хорошую читаемость вашего кода, а также автоматически проверяет ваш код на наличие ошибок._

Для более удобной работы с линтерами, я советую вам установить расширения `Stylelint`, `ESLint`, `puglint` в ваших IDE. Чтобы ваш код автоматически форматировался при сохранении, я также рекомендую установить расширение `Prettier`.

#### Простая проверка кода

```
$ yarn run lint:pug          # проверяет Pug-код на ошибки
$ yarn run lint:styles       # проверяет SCSS-код на ошибки
$ yarn run lint:scripts      # проверяет JS-код на ошибки
```

#### Автоматическое исправление

```
$ yarn run lint:styles --fix      # исправить все ошиби в SCSS-коде
$ yarn run lint:scripts --fix     # исправить все ошибки в JS-коде
```

К сожалению, автоматическое исправление Pug-кода недоступно, так как создатель [Pug-linter](https://github.com/pugjs/pug-lint) не реализовал флаг `--fix`. Так что в случае с Pug, вам придётся использовать `yarn run lint:pug` и исправлять ошибки вручную. Пока что.

## Генератор компонентов

_Создать пустой компонент по имени в папке `src/components`._

По умолчанию создаёт только `*.pug`, `*.scss` и `*.js` файлы.

Синтаксис:

```console
$ bem create <component-name> <args>
```

Если вам нужно создать только один тип файла, используйте флаг `-T`:

```console
$ bem create header -T pug
```

Если вам нужно создать компонент без одного или нескольких дефолтных типов файлов, используйте флаг `-n`:

```console
$ bem create header -n js
```

Если вам нужно добавить ещё один тип файлов к вашему компоненту, используйте флаг `-t`:

```console
$ bem create header -t md
```

Вы также можете комбинировать флаги:

```console
$ bem create menu -n js -t yml
```

## Лицензия

[The GPL3.0 License (GPL3.0 only)](./LICENSE)
